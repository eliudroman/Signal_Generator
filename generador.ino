#include <LiquidCrystal.h>

// Inicializar la biblioteca con los números de los pines
LiquidCrystal lcd(A5, A4, A0, A1, A2, 13);

const int cambioPin = 11;
const int enterPin = 12;

const int frecuenciaPin = A7;
const int amplitudPin = A6;
const int offsetPin = A3;

const PROGMEM byte R2RLookup_Sine[256] = {
  0x80,0x83,0x86,0x89,0x8c,0x8f,0x92,0x95,0x98,0x9c,0x9f,0xa2,0xa5,0xa8,0xab,0xae,
  0xb0,0xb3,0xb6,0xb9,0xbc,0xbf,0xc1,0xc4,0xc7,0xc9,0xcc,0xce,0xd1,0xd3,0xd5,0xd8,
  0xda,0xdc,0xde,0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xed,0xef,0xf0,0xf2,0xf3,0xf5,
  0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfc,0xfd,0xfe,0xfe,0xff,0xff,0xff,0xff,0xff,
  0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xfe,0xfd,0xfc,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,
  0xf6,0xf5,0xf3,0xf2,0xf0,0xef,0xed,0xec,0xea,0xe8,0xe6,0xe4,0xe2,0xe0,0xde,0xdc,
  0xda,0xd8,0xd5,0xd3,0xd1,0xce,0xcc,0xc9,0xc7,0xc4,0xc1,0xbf,0xbc,0xb9,0xb6,0xb3,
  0xb0,0xae,0xab,0xa8,0xa5,0xa2,0x9f,0x9c,0x98,0x95,0x92,0x8f,0x8c,0x89,0x86,0x83,
  0x80,0x7c,0x79,0x76,0x73,0x70,0x6d,0x6a,0x67,0x63,0x60,0x5d,0x5a,0x57,0x54,0x51,
  0x4f,0x4c,0x49,0x46,0x43,0x40,0x3e,0x3b,0x38,0x36,0x33,0x31,0x2e,0x2c,0x2a,0x27,
  0x25,0x23,0x21,0x1f,0x1d,0x1b,0x19,0x17,0x15,0x13,0x12,0x10,0x0f,0x0d,0x0c,0x0a,
  0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x03,0x02,0x01,0x01,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x02,0x03,0x03,0x04,0x05,0x06,0x07,0x08,
  0x09,0x0a,0x0c,0x0d,0x0f,0x10,0x12,0x13,0x15,0x17,0x19,0x1b,0x1d,0x1f,0x21,0x23,
  0x25,0x27,0x2a,0x2c,0x2e,0x31,0x33,0x36,0x38,0x3b,0x3e,0x40,0x43,0x46,0x49,0x4c,
  0x4f,0x51,0x54,0x57,0x5a,0x5d,0x60,0x63,0x67,0x6a,0x6d,0x70,0x73,0x76,0x79,0x7c
};


const PROGMEM byte R2RLookup_Sawtooth[256] =
{
0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
};


const PROGMEM byte R2RLookup_Square[256] = {
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // Alto
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // Alto
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // Alto
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // Alto
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bajo
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bajo
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bajo
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bajo
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // Alto
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // Alto
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // Alto
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // Alto
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bajo
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bajo
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bajo
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // Bajo
};


enum Mode {
  SINE,
  RAMP,
  SQUARE
};

Mode currentMode = SINE;

float SNR(float factorEscala) {
  float signalPower = pow(255.0 * factorEscala, 2) / 2;
  float noisePower = pow(5.0 / 255.0, 2) / 12;
  float snr = 10 * log10(signalPower / noisePower);
  return snr;
}



void setup() {
  pinMode(cambioPin, INPUT);
  pinMode(enterPin, INPUT);

  pinMode(frecuenciaPin, INPUT);
  pinMode(amplitudPin, INPUT);
  pinMode(offsetPin, INPUT);

  pinMode(2, OUTPUT);
  pinMode(3, OUTPUT);
  pinMode(4, OUTPUT);
  pinMode(5, OUTPUT);
  pinMode(6, OUTPUT);
  
  pinMode(7, OUTPUT);
  pinMode(8, OUTPUT);
  pinMode(9, OUTPUT);

  lcd.begin(16, 2);

  displayMenu();
}

void loop() {
  static bool cambioButtonPressed = false;
  static bool enterButtonPressed = false;

  if (digitalRead(cambioPin) == HIGH) {
    if (!cambioButtonPressed) {
      cambioButtonPressed = true;
      // Cambiar entre modos
      currentMode = (Mode)((currentMode + 1) % 3);
      displayMenu();
    }
  } else {
    cambioButtonPressed = false;
  }

  if (digitalRead(enterPin) == HIGH) {
    if (!enterButtonPressed) {
      enterButtonPressed = true;
      // Comienza a generar la señal
      generateSignal();
    }
  } else {
    enterButtonPressed = false;
  }
}

void displayMenu() {
  lcd.clear(); // Borra todo el contenido del LCD
  lcd.setCursor(0, 0);

  switch (currentMode) {
    case SINE:
      lcd.print("Modo: Seno");
      break;
    case RAMP:
      lcd.print("Modo: Rampa");
      break;
    case SQUARE:
      lcd.print("Modo: Cuadrada");
      break;
  }

  lcd.setCursor(0, 1);
  lcd.print("Presiona Enter");
}

void generateSignal() {
  lcd.clear();
  
  switch (currentMode) {
    case SINE:
      
      
      while(digitalRead(cambioPin) == LOW){
        lcd.setCursor(0, 0);
        lcd.print("Seno");
        int amplitud = analogRead(amplitudPin);  // Lee el valor del pin de amplitud (0-1023)
        float factorEscala = amplitud / 1023.0;  // Calcula el factor de escala (0.0-1.0)
        float Offset = analogRead(offsetPin) / 1023.0;
        int frecuencia = 0.01 + (10 * analogRead(frecuenciaPin) / 1023.0);

        float SnrActual = SNR(factorEscala);
        lcd.setCursor(0, 1);
        lcd.print("SNR= ");
        lcd.print(SnrActual);
        Serial.println(SnrActual);
        for (int i = 0; i < 256; i++) {
          byte valorOriginal = pgm_read_byte(&R2RLookup_Sine[i]);
          byte valorEscalado = valorOriginal * factorEscala + Offset;
          PORTD = valorEscalado;  // Aplica el valor escalado a los pines de salida
          delayMicroseconds(frecuencia);
          //delay(250);
        }
        lcd.clear();
      }
      break;
    case RAMP:
      while(digitalRead(cambioPin) == LOW){
        lcd.setCursor(0, 0);
        lcd.print("Rampa");
        int amplitud = analogRead(amplitudPin);  // Lee el valor del pin de amplitud (0-1023)
        float factorEscala = amplitud / 1023.0;  // Calcula el factor de escala (0.0-1.0)
        int frecuencia = 0.01 + (10 * analogRead(frecuenciaPin) / 1023.0);

        float SnrActual = SNR(factorEscala);
        lcd.setCursor(0, 1);
        lcd.print("SNR= ");
        lcd.print(SnrActual);
        Serial.println(SnrActual);
        for (int i = 0; i < 256; i++) {
          byte valorOriginal = pgm_read_byte(&R2RLookup_Sawtooth[i]);
          byte valorEscalado = valorOriginal * factorEscala;
          PORTD = valorEscalado;  // Aplica el valor escalado a los pines de salida
          delayMicroseconds(frecuencia);
          //delay(250);
        }
        lcd.clear();
      }
      
      break;
    case SQUARE:
      while(digitalRead(cambioPin) == LOW){
        lcd.setCursor(0, 0);
        lcd.print("Cuadrada");
        int amplitud = analogRead(amplitudPin);  // Lee el valor del pin de amplitud (0-1023)
        float factorEscala = amplitud / 1023.0;  // Calcula el factor de escala (0.0-1.0)
        int frecuencia = 0.01 + (10 * analogRead(frecuenciaPin) / 1023.0);

        float SnrActual = SNR(factorEscala);
        lcd.setCursor(0, 1);
        lcd.print("SNR= ");
        lcd.print(SnrActual);
        Serial.println(SnrActual);
        for (int i = 0; i < 256; i++) {
          byte valorOriginal = pgm_read_byte(&R2RLookup_Square[i]);
          byte valorEscalado = valorOriginal * factorEscala;
          PORTD = valorEscalado;  // Aplica el valor escalado a los pines de salida
          delayMicroseconds(frecuencia);
          //delay(250);
        }
        lcd.clear();
      }
      
      break;
  }
  displayMenu();
}
